// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"sync"

	"github.com/rinosukmandityo/login-jwt"
)

// Ensure, that AuthServiceMock does implement login.AuthService.
// If this is not the case, regenerate this file with moq.
var _ login.AuthService = &AuthServiceMock{}

// AuthServiceMock is a mock implementation of login.AuthService.
//
//	func TestSomethingThatUsesAuthService(t *testing.T) {
//
//		// make and configure a mocked login.AuthService
//		mockedAuthService := &AuthServiceMock{
//			BuildJWTFunc: func(ctx context.Context, claims *login.Claims) (string, error) {
//				panic("mock out the BuildJWT method")
//			},
//			LoginUserFunc: func(ctx context.Context, req *login.LoginUserRequest) (*login.Claims, error) {
//				panic("mock out the LoginUser method")
//			},
//			LogoutFunc: func(ctx context.Context) error {
//				panic("mock out the Logout method")
//			},
//			ParseTokenFunc: func(ctx context.Context, token string) (*login.Claims, error) {
//				panic("mock out the ParseToken method")
//			},
//			RefreshTokenFunc: func(ctx context.Context) (*login.Claims, error) {
//				panic("mock out the RefreshToken method")
//			},
//			ValidateTokenFunc: func(ctx context.Context) (bool, error) {
//				panic("mock out the ValidateToken method")
//			},
//		}
//
//		// use mockedAuthService in code that requires login.AuthService
//		// and then make assertions.
//
//	}
type AuthServiceMock struct {
	// BuildJWTFunc mocks the BuildJWT method.
	BuildJWTFunc func(ctx context.Context, claims *login.Claims) (string, error)

	// LoginUserFunc mocks the LoginUser method.
	LoginUserFunc func(ctx context.Context, req *login.LoginUserRequest) (*login.Claims, error)

	// LogoutFunc mocks the Logout method.
	LogoutFunc func(ctx context.Context) error

	// ParseTokenFunc mocks the ParseToken method.
	ParseTokenFunc func(ctx context.Context, token string) (*login.Claims, error)

	// RefreshTokenFunc mocks the RefreshToken method.
	RefreshTokenFunc func(ctx context.Context) (*login.Claims, error)

	// ValidateTokenFunc mocks the ValidateToken method.
	ValidateTokenFunc func(ctx context.Context) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// BuildJWT holds details about calls to the BuildJWT method.
		BuildJWT []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Claims is the claims argument value.
			Claims *login.Claims
		}
		// LoginUser holds details about calls to the LoginUser method.
		LoginUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *login.LoginUserRequest
		}
		// Logout holds details about calls to the Logout method.
		Logout []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ParseToken holds details about calls to the ParseToken method.
		ParseToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token string
		}
		// RefreshToken holds details about calls to the RefreshToken method.
		RefreshToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ValidateToken holds details about calls to the ValidateToken method.
		ValidateToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockBuildJWT      sync.RWMutex
	lockLoginUser     sync.RWMutex
	lockLogout        sync.RWMutex
	lockParseToken    sync.RWMutex
	lockRefreshToken  sync.RWMutex
	lockValidateToken sync.RWMutex
}

// BuildJWT calls BuildJWTFunc.
func (mock *AuthServiceMock) BuildJWT(ctx context.Context, claims *login.Claims) (string, error) {
	if mock.BuildJWTFunc == nil {
		panic("AuthServiceMock.BuildJWTFunc: method is nil but AuthService.BuildJWT was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Claims *login.Claims
	}{
		Ctx:    ctx,
		Claims: claims,
	}
	mock.lockBuildJWT.Lock()
	mock.calls.BuildJWT = append(mock.calls.BuildJWT, callInfo)
	mock.lockBuildJWT.Unlock()
	return mock.BuildJWTFunc(ctx, claims)
}

// BuildJWTCalls gets all the calls that were made to BuildJWT.
// Check the length with:
//
//	len(mockedAuthService.BuildJWTCalls())
func (mock *AuthServiceMock) BuildJWTCalls() []struct {
	Ctx    context.Context
	Claims *login.Claims
} {
	var calls []struct {
		Ctx    context.Context
		Claims *login.Claims
	}
	mock.lockBuildJWT.RLock()
	calls = mock.calls.BuildJWT
	mock.lockBuildJWT.RUnlock()
	return calls
}

// LoginUser calls LoginUserFunc.
func (mock *AuthServiceMock) LoginUser(ctx context.Context, req *login.LoginUserRequest) (*login.Claims, error) {
	if mock.LoginUserFunc == nil {
		panic("AuthServiceMock.LoginUserFunc: method is nil but AuthService.LoginUser was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *login.LoginUserRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockLoginUser.Lock()
	mock.calls.LoginUser = append(mock.calls.LoginUser, callInfo)
	mock.lockLoginUser.Unlock()
	return mock.LoginUserFunc(ctx, req)
}

// LoginUserCalls gets all the calls that were made to LoginUser.
// Check the length with:
//
//	len(mockedAuthService.LoginUserCalls())
func (mock *AuthServiceMock) LoginUserCalls() []struct {
	Ctx context.Context
	Req *login.LoginUserRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *login.LoginUserRequest
	}
	mock.lockLoginUser.RLock()
	calls = mock.calls.LoginUser
	mock.lockLoginUser.RUnlock()
	return calls
}

// Logout calls LogoutFunc.
func (mock *AuthServiceMock) Logout(ctx context.Context) error {
	if mock.LogoutFunc == nil {
		panic("AuthServiceMock.LogoutFunc: method is nil but AuthService.Logout was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockLogout.Lock()
	mock.calls.Logout = append(mock.calls.Logout, callInfo)
	mock.lockLogout.Unlock()
	return mock.LogoutFunc(ctx)
}

// LogoutCalls gets all the calls that were made to Logout.
// Check the length with:
//
//	len(mockedAuthService.LogoutCalls())
func (mock *AuthServiceMock) LogoutCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockLogout.RLock()
	calls = mock.calls.Logout
	mock.lockLogout.RUnlock()
	return calls
}

// ParseToken calls ParseTokenFunc.
func (mock *AuthServiceMock) ParseToken(ctx context.Context, token string) (*login.Claims, error) {
	if mock.ParseTokenFunc == nil {
		panic("AuthServiceMock.ParseTokenFunc: method is nil but AuthService.ParseToken was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token string
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockParseToken.Lock()
	mock.calls.ParseToken = append(mock.calls.ParseToken, callInfo)
	mock.lockParseToken.Unlock()
	return mock.ParseTokenFunc(ctx, token)
}

// ParseTokenCalls gets all the calls that were made to ParseToken.
// Check the length with:
//
//	len(mockedAuthService.ParseTokenCalls())
func (mock *AuthServiceMock) ParseTokenCalls() []struct {
	Ctx   context.Context
	Token string
} {
	var calls []struct {
		Ctx   context.Context
		Token string
	}
	mock.lockParseToken.RLock()
	calls = mock.calls.ParseToken
	mock.lockParseToken.RUnlock()
	return calls
}

// RefreshToken calls RefreshTokenFunc.
func (mock *AuthServiceMock) RefreshToken(ctx context.Context) (*login.Claims, error) {
	if mock.RefreshTokenFunc == nil {
		panic("AuthServiceMock.RefreshTokenFunc: method is nil but AuthService.RefreshToken was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRefreshToken.Lock()
	mock.calls.RefreshToken = append(mock.calls.RefreshToken, callInfo)
	mock.lockRefreshToken.Unlock()
	return mock.RefreshTokenFunc(ctx)
}

// RefreshTokenCalls gets all the calls that were made to RefreshToken.
// Check the length with:
//
//	len(mockedAuthService.RefreshTokenCalls())
func (mock *AuthServiceMock) RefreshTokenCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRefreshToken.RLock()
	calls = mock.calls.RefreshToken
	mock.lockRefreshToken.RUnlock()
	return calls
}

// ValidateToken calls ValidateTokenFunc.
func (mock *AuthServiceMock) ValidateToken(ctx context.Context) (bool, error) {
	if mock.ValidateTokenFunc == nil {
		panic("AuthServiceMock.ValidateTokenFunc: method is nil but AuthService.ValidateToken was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockValidateToken.Lock()
	mock.calls.ValidateToken = append(mock.calls.ValidateToken, callInfo)
	mock.lockValidateToken.Unlock()
	return mock.ValidateTokenFunc(ctx)
}

// ValidateTokenCalls gets all the calls that were made to ValidateToken.
// Check the length with:
//
//	len(mockedAuthService.ValidateTokenCalls())
func (mock *AuthServiceMock) ValidateTokenCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockValidateToken.RLock()
	calls = mock.calls.ValidateToken
	mock.lockValidateToken.RUnlock()
	return calls
}
